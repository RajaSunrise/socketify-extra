saya ingin AppResponse menggunakan picohttpparser dan ubah jadi parsing menggunakan picohttpparser

dan perhatikan pico.py menggunakan lib2 dan ffi2 sedangkan uws.py menggunakan lib dan ffi

ini adalah file response.py
```
from typing import Union
from http import cookies
from datetime import datetime
from io import BytesIO
from urllib.parse import quote_plus, parse_qs, unquote_plus

import uuid
import inspect
import logging

from .background import (
    uws_generic_cork_handler, uws_generic_aborted_handler,
    uws_generic_on_data_handler, uws_generic_on_writable_handler
)
from .uws import lib, ffi
from .pico import ffi2, lib2
from .request import AppRequest


class AppResponse:
    def __init__(self, response, app, request_data):
        self.res = response
        self.app = app
        self.aborted = False
        self._aborted_handler = None
        self._writable_handler = None
        self._data_handler = None
        self._ptr = ffi.new_handle(self)
        self._grabbed_abort_handler_once = False
        self._write_jar = None
        self._cork_handler = None
        self._lastChunkOffset = 0
        self._chunkFuture = None
        self._dataFuture = None
        self._data = None

        self._phr_ctx = ffi.new("phr_parse_context *")

        # Parse request data using picohttpparser
        self._parse_request_data(request_data)
    
    def _parse_request_data(self, request_data):
        self.method = ""
        self.path = ""
        self.query_string = ""
        self.headers = {}

        # Initialize picohttpparser context
        lib2.phr_parse_request(
            request_data,
            len(request_data),
            ffi.NULL,  # method
            ffi.NULL,  # method_len
            ffi.NULL,  # path
            ffi.NULL,  # path_len
            ffi.NULL,  # query_string
            ffi.NULL,  # query_string_len
            ffi.NULL,  # headers
            ffi.NULL,  # num_headers
            self._phr_ctx  # context
        )

        # Parse headers
        headers_buffer = ffi.new("phr_header[10]")
        num_headers = lib2.phr_parse_headers(
            request_data[self._phr_ctx.off:],
            len(request_data) - self._phr_ctx.off,
            headers_buffer,
            10,
            self._phr_ctx
        )

        if num_headers == -1:
            # Error parsing headers
            return

        # Populate headers dictionary
        for i in range(num_headers):
            name = ffi.string(headers_buffer[i].name, headers_buffer[i].name_len).decode('utf-8')
            value = ffi.string(headers_buffer[i].value, headers_buffer[i].value_len).decode('utf-8')
            self.headers[name] = value

        # Extract method, path, and query string
        self.method = ffi.string(self._phr_ctx.method, self._phr_ctx.method_len).decode('utf-8')
        self.path = ffi.string(self._phr_ctx.path, self._phr_ctx.path_len).decode('utf-8')
        self.query_string = ffi.string(self._phr_ctx.query_string, self._phr_ctx.query_string_len).decode('utf-8')


    def cork(self, callback):
        self.app.loop.is_idle = False
        
        if not self.aborted:
            self.grab_aborted_handler()
            self._cork_handler = callback
            lib.uws_res_cork(
                self.app.SSL, self.res, uws_generic_cork_handler, self._ptr
            )

    def set_cookie(self, name, value, options):
        if options is None:
            options = {}
        if self._write_jar is None:
            self._write_jar = cookies.SimpleCookie()
        self._write_jar[name] = quote_plus(value)
        if isinstance(options, dict):
            for key in options:
                if key == "expires" and isinstance(options[key], datetime):
                    self._write_jar[name][key] = options[key].strftime(
                        "%a, %d %b %Y %H:%M:%S GMT"
                    )
                else:
                    self._write_jar[name][key] = options[key]

    def trigger_aborted(self):
        self.aborted = True
        self._ptr = ffi.NULL
        self.res = ffi.NULL
        if hasattr(self, "_aborted_handler") and hasattr(
            self._aborted_handler, "__call__"
        ):
            try:
                if inspect.iscoroutinefunction(self._aborted_handler):
                    self.run_async(self._aborted_handler(self))
                else:
                    self._aborted_handler(self)
            except Exception as err:
                logging.error("Error on abort handler %s" % str(err))
        return self

    def trigger_data_handler(self, data, is_end):
        if self.aborted:
            return self
        if hasattr(self, "_data_handler") and hasattr(self._data_handler, "__call__"):
            try:
                if inspect.iscoroutinefunction(self._data_handler):
                    self.run_async(self._data_handler(self, data, is_end))
                else:
                    self._data_handler(self, data, is_end)
            except Exception as err:
                logging.error("Error on data handler %s" % str(err))

        return self

    def trigger_writable_handler(self, offset):
        if self.aborted:
            return False
        if hasattr(self, "_writable_handler") and hasattr(
            self._writable_handler, "__call__"
        ):
            try:
                if inspect.iscoroutinefunction(self._writable_handler):
                    raise RuntimeError("AppResponse.on_writable must be synchronous")
                return self._writable_handler(self, offset)
            except Exception as err:
                logging.error("Error on writable handler %s" % str(err))
            return False
        return False

    def run_async(self, task):
        self.grab_aborted_handler()
        return self.app.loop.run_async(task, self)

    async def get_form_urlencoded(self, encoding="utf-8"):
        data = await self.get_data()
        try:
            result = {}
            parsed = parse_qs(data.getvalue(), encoding=encoding)
            has_value = False
            for key in parsed:
                has_value = True
                try:
                    value = parsed[key]
                    new_key = key.decode(encoding)
                    last_value = value[len(value) - 1]

                    result[new_key] = unquote_plus(last_value.decode(encoding))
                except ValueError:
                    pass
            return result if has_value else None
        except ValueError:
            return None

    async def get_text(self, encoding="utf-8"):
        data = await self.get_data()
        try:
            return data.getvalue().decode(encoding)
        except Exception:
            return None

    async def get_json(self):
        content_type = self.headers.get("Content-Type", "")
        if "application/json" in content_type:
            data = await self.get_data()
            try:
                return self.app._json_serializer.loads(data.getvalue().decode("utf-8"))
            except Exception:
                return None
        return None


    def send_chunk(self, buffer, total_size):
        self._chunkFuture = self.app.loop.create_future()
        self._lastChunkOffset = 0

        def is_aborted(self):
            self.aborted = True
            try:
                if not self._chunkFuture.done():
                    self._chunkFuture.set_result(
                        (False, True)
                    )
            except Exception:
                pass

        def on_writeble(self, offset):
            (ok, done) = self.try_end(
                buffer[offset - self._lastChunkOffset : :], total_size
            )
            if ok:
                self._chunkFuture.set_result((ok, done))
            return ok

        self.on_writable(on_writeble)
        self.on_aborted(is_aborted)

        if self.aborted:
            self._chunkFuture.set_result(
                (False, True)
            )
            return self._chunkFuture

        self._lastChunkOffset = self.get_write_offset()

        (ok, done) = self.try_end(buffer, total_size)
        if ok:
            self._chunkFuture.set_result((ok, done))
            return self._chunkFuture

        # failed to send chunk
        return self._chunkFuture

    def get_data(self):
        self._dataFuture = self.app.loop.create_future()
        self._data = BytesIO()

        def is_aborted(self):
            self.aborted = True
            try:
                if not self._dataFuture.done():
                    self._dataFuture.set_result(self._data)
            except Exception:
                pass

        def get_chunks(self, chunk, is_end):
            if chunk is not None:
                self._data.write(chunk)
            if is_end:
                self._dataFuture.set_result(self._data)
                self._data = None

        self.on_aborted(is_aborted)
        self.on_data(get_chunks)
        return self._dataFuture

    def grab_aborted_handler(self):
        # only needed if is async
        if not self.aborted and not self._grabbed_abort_handler_once:
            self._grabbed_abort_handler_once = True
            lib.uws_res_on_aborted(
                self.app.SSL, self.res, uws_generic_aborted_handler, self._ptr
            )
        return self

    def redirect(self, location, status_code=302):
        self.write_status(status_code)
        self.write_header("Location", location)
        self.end_without_body(False)
        return self

    def write_offset(self, offset):
        lib.uws_res_override_write_offset(
            self.app.SSL, self.res, ffi.cast("uintmax_t", offset)
        )
        return self

    def close(self):
        lib.uws_res_close(
            self.app.SSL, self.res
        )
        return self

    def try_end(self, message, total_size, end_connection=False):
        self.app.loop.is_idle = False
        try:
            if self.aborted:
                return False, True
            if self._write_jar is not None:
                self.write_header("Set-Cookie", self._write_jar.output(header=""))
                self._write_jar = None
            if isinstance(message, str):
                data = message.encode("utf-8")
            elif isinstance(message, bytes):
                data = message
            else:
                return False, True
            result = lib.uws_res_try_end(
                self.app.SSL,
                self.res,
                data,
                len(data),
                ffi.cast("uintmax_t", total_size),
                1 if end_connection else 0,
            )
            return bool(result.ok), bool(result.has_responded)
        except Exception:
            return False, True

    def cork_end(self, message, end_connection=False):
        self.cork(lambda res: res.end(message, end_connection))
        return self

    def render(self, *args, **kwargs):
        if self.app._template:

            def render(res):
                res.write_header(b"Content-Type", b"text/html")
                res.end(self.app._template.render(*args, **kwargs))

            self.cork(render)
            return self
        raise RuntimeError("No registered templated engine")

    def get_remote_address_bytes(self):
        buffer = ffi.new("char**")
        length = lib.uws_res_get_remote_address(self.app.SSL, self.res, buffer)
        buffer_address = ffi.addressof(buffer, 0)[0]
        if buffer_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(buffer_address, length)
        except Exception:  # invalid
            return None

    def get_remote_address(self):
        buffer = ffi.new("char**")
        length = lib.uws_res_get_remote_address_as_text(self.app.SSL, self.res, buffer)
        buffer_address = ffi.addressof(buffer, 0)[0]
        if buffer_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(buffer_address, length).decode("utf-8")
        except Exception:  # invalid utf-8
            return None

    def get_proxied_remote_address_bytes(self):
        buffer = ffi.new("char**")
        length = lib.uws_res_get_proxied_remote_address(self.app.SSL, self.res, buffer)
        buffer_address = ffi.addressof(buffer, 0)[0]
        if buffer_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(buffer_address, length)
        except Exception:  # invalid
            return None

    def get_proxied_remote_address(self):
        buffer = ffi.new("char**")
        length = lib.uws_res_get_proxied_remote_address_as_text(
            self.app.SSL, self.res, buffer
        )
        buffer_address = ffi.addressof(buffer, 0)[0]
        if buffer_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(buffer_address, length).decode("utf-8")
        except Exception:  # invalid utf-8
            return None

    def cork_send(
        self,
        message: any,
        content_type: Union[str, bytes] = b"text/plain",
        status: Union[str, bytes, int] = b"200 OK",
        headers=None,
        end_connection: bool = False,
    ):
        # TODO: use socketify_res_cork_send_int_code and socketify_res_cork_send after optimize headers
        self.cork(
            lambda res: res.send(message, content_type, status, headers, end_connection)
        )
        return self

    def send(
        self,
        message: any = b"",
        content_type: Union[str, bytes] = b"text/plain",
        status: Union[str, bytes, int] = b"200 OK",
        headers = None,
        end_connection: bool = False,
    ):
        self.app.loop.is_idle = False
        
        # TODO: optimize headers
        if headers is not None:
            for name, value in headers:
                self.write_header(name, value)
        try:

            # TODO: optimize Set-Cookie
            if self._write_jar is not None:
                self.write_header("Set-Cookie", self._write_jar.output(header=""))
                self._write_jar = None

            if isinstance(message, str):
                data = message.encode("utf-8")
            elif isinstance(message, bytes):
                data = message
            elif message is None:
                if isinstance(status, int):
                    lib.socketify_res_send_int_code(
                        self.app.SSL,
                        self.res,
                        ffi.NULL,
                        0,
                        status,
                        content_type,
                        len(content_type),
                        1 if end_connection else 0,
                    )
                elif isinstance(status, str):
                    status = status.encode("utf-8")
                    lib.socketify_res_send(
                        self.app.SSL,
                        self.res,
                        ffi.NULL,
                        0,
                        status,
                        len(status),
                        content_type,
                        len(content_type),
                        1 if end_connection else 0,
                    )
                else:
                    lib.socketify_res_send(
                        self.app.SSL,
                        self.res,
                        ffi.NULL,
                        0,
                        status,
                        len(status),
                        content_type,
                        len(content_type),
                        1 if end_connection else 0,
                    )
                return self
            else:
                data = self.app._json_serializer.dumps(message).encode("utf-8")
                content_type = b"application/json"

            if isinstance(status, int):
                lib.socketify_res_send_int_code(
                    self.app.SSL,
                    self.res,
                    data,
                    len(data),
                    status,
                    content_type,
                    len(content_type),
                    1 if end_connection else 0,
                )
            elif isinstance(status, str):
                status = status.encode("utf-8")
                lib.socketify_res_send(
                    self.app.SSL,
                    self.res,
                    ffi.NULL,
                    0,
                    status,
                    len(status),
                    content_type,
                    len(content_type),
                    1 if end_connection else 0,
                )
            else:
                lib.socketify_res_send(
                    self.app.SSL,
                    self.res,
                    data,
                    len(data),
                    status,
                    len(status),
                    content_type,
                    len(content_type),
                    1 if end_connection else 0,
                )

        finally:
            return self

    def end(self, message, end_connection=False):
        self.app.loop.is_idle = False
        
        try:
            if self.aborted:
                return self
            if self._write_jar is not None:
                self.write_header("Set-Cookie", self._write_jar.output(header=""))
                self._write_jar = None
            if isinstance(message, str):
                data = message.encode("utf-8")
            elif isinstance(message, bytes):
                data = message
            elif message is None:
                self.end_without_body(end_connection)
                return self
            else:
                self.write_header(b"Content-Type", b"application/json")
                data = self.app._json_serializer.dumps(message).encode("utf-8")
            lib.uws_res_end(
                self.app.SSL, self.res, data, len(data), 1 if end_connection else 0
            )
        finally:
            return self

    def pause(self):
        if not self.aborted:
            lib.uws_res_pause(self.app.SSL, self.res)
        return self

    def resume(self):
        self.app.loop.is_idle = False
        if not self.aborted:
            lib.uws_res_resume(self.app.SSL, self.res)
        return self

    def write_continue(self):
        self.app.loop.is_idle = False
        if not self.aborted:
            lib.uws_res_write_continue(self.app.SSL, self.res)
        return self

    def write_status(self, status_or_status_text):
        self.app.loop.is_idle = False
        if not self.aborted:
            if isinstance(status_or_status_text, int):
                if bool(
                    lib.socketify_res_write_int_status(
                        self.app.SSL, self.res, status_or_status_text
                    )
                ):
                    return self
                raise RuntimeError(
                    '"%d" Is not an valid Status Code' % status_or_status_text
                )

            elif isinstance(status_or_status_text, str):
                data = status_or_status_text.encode("utf-8")
            elif isinstance(status_or_status_text, bytes):
                data = status_or_status_text
            else:
                data = self.app._json_serializer.dumps(status_or_status_text).encode(
                    "utf-8"
                )

            lib.uws_res_write_status(self.app.SSL, self.res, data, len(data))
        return self

    def write_header(self, key, value):
        self.app.loop.is_idle = False
        if not self.aborted:
            if isinstance(key, str):
                key_data = key.encode("utf-8")
            elif isinstance(key, bytes):
                key_data = key
            else:
                key_data = self.app._json_serializer.dumps(key).encode("utf-8")

            if isinstance(value, int):
                lib.uws_res_write_header_int(
                    self.app.SSL,
                    self.res,
                    key_data,
                    len(key_data),
                    ffi.cast("uint64_t", value),
                )
            elif isinstance(value, str):
                value_data = value.encode("utf-8")
            elif isinstance(value, bytes):
                value_data = value
            else:
                value_data = self.app._json_serializer.dumps(value).encode("utf-8")
            lib.uws_res_write_header(
                self.app.SSL,
                self.res,
                key_data,
                len(key_data),
                value_data,
                len(value_data),
            )
        return self

    def end_without_body(self, end_connection=False):
        self.app.loop.is_idle = False
        if not self.aborted:
            if self._write_jar is not None:
                self.write_header("Set-Cookie", self._write_jar.output(header=""))
            lib.uws_res_end_without_body(
                self.app.SSL, self.res, 1 if end_connection else 0
            )
        return self

    def write(self, message):
        self.app.loop.is_idle = False
        if not self.aborted:
            if isinstance(message, str):
                data = message.encode("utf-8")
            elif isinstance(message, bytes):
                data = message
            else:
                data = self.app._json_serializer.dumps(message).encode("utf-8")
            lib.uws_res_write(self.app.SSL, self.res, data, len(data))
        return self

    def get_write_offset(self):
        if not self.aborted:
            return int(lib.uws_res_get_write_offset(self.app.SSL, self.res))
        return 0

    def has_responded(self):
        if self.aborted:
            return False
        return bool(lib.uws_res_has_responded(self.app.SSL, self.res))

    def on_aborted(self, handler):
        if hasattr(handler, "__call__"):
            self._aborted_handler = handler
            self.grab_aborted_handler()
        return self

    def on_data(self, handler):
        if not self.aborted:
            if hasattr(handler, "__call__"):
                self._data_handler = handler
                self.grab_aborted_handler()
                lib.uws_res_on_data(
                    self.app.SSL, self.res, uws_generic_on_data_handler, self._ptr
                )
        return self

    def upgrade(
        self,
        sec_web_socket_key,
        sec_web_socket_protocol,
        sec_web_socket_extensions,
        socket_context,
        user_data=None,
    ):
        if self.aborted:
            return False

        if isinstance(sec_web_socket_key, str):
            sec_web_socket_key_data = sec_web_socket_key.encode("utf-8")
        elif isinstance(sec_web_socket_key, bytes):
            sec_web_socket_key_data = sec_web_socket_key
        else:
            sec_web_socket_key_data = b""

        if isinstance(sec_web_socket_protocol, str):
            sec_web_socket_protocol_data = sec_web_socket_protocol.encode("utf-8")
        elif isinstance(sec_web_socket_protocol, bytes):
            sec_web_socket_protocol_data = sec_web_socket_protocol
        else:
            sec_web_socket_protocol_data = b""

        if isinstance(sec_web_socket_extensions, str):
            sec_web_socket_extensions_data = sec_web_socket_extensions.encode("utf-8")
        elif isinstance(sec_web_socket_extensions, bytes):
            sec_web_socket_extensions_data = sec_web_socket_extensions
        else:
            sec_web_socket_extensions_data = b""

        user_data_ptr = ffi.NULL
        if user_data is not None:
            _id = uuid.uuid4()
            user_data_ptr = ffi.new_handle((user_data, _id))
            # keep alive data
            self.app._socket_refs[_id] = user_data_ptr

        lib.uws_res_upgrade(
            self.app.SSL,
            self.res,
            user_data_ptr,
            sec_web_socket_key_data,
            len(sec_web_socket_key_data),
            sec_web_socket_protocol_data,
            len(sec_web_socket_protocol_data),
            sec_web_socket_extensions_data,
            len(sec_web_socket_extensions_data),
            socket_context,
        )
        return True

    def on_writable(self, handler):
        if not self.aborted:
            if hasattr(handler, "__call__"):
                self._writable_handler = handler
                self.grab_aborted_handler()
                lib.uws_res_on_writable(
                    self.app.SSL, self.res, uws_generic_on_writable_handler, self._ptr
                )
        return self

    def get_native_handle(self):
        return lib.uws_res_get_native_handle(self.app.SSL, self.res)
    
    def get_method(self):
        # Assume 'self.req' is a pointer to a uws_req_t struct
        method_buffer = ffi.new("char**") 
        method_length = lib2.uws_req_get_method(self.req, method_buffer)
        method_address = ffi.addressof(method_buffer, 0)[0]
        if method_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(method_address, method_length).decode("utf-8")
        except Exception:  # invalid utf-8
            return None

    def get_path(self):
        # Assume 'self.req' is a pointer to a uws_req_t struct
        path_buffer = ffi.new("char**") 
        path_length = lib2.uws_req_get_url(self.req, path_buffer)
        path_address = ffi.addressof(path_buffer, 0)[0]
        if path_address == ffi.NULL:
            return None
        try:
            return ffi.unpack(path_address, path_length).decode("utf-8")
        except Exception:  # invalid utf-8
            return None

    
    def __del__(self):
        self.res = ffi.NULL
        self._ptr = ffi.NULL

```

dan ini adalah file dari pico.py
```
import cffi
import platform
import os

ffi2 = cffi.FFI()
ffi2.cdef(
    """
/* picohttpparser */

typedef struct phr_header {
    const char *name;
    size_t name_len;
    const char *value;
    size_t value_len;
} phr_header;

typedef struct phr_parse_context {
  char *buf;
  size_t buflen;
  size_t off;
  int minor_version;
  int method;
  const char *path;
  size_t path_len;
  const char *query_string;
  size_t query_string_len;
  phr_header *headers;
  size_t num_headers;
  size_t max_headers;
  int is_head;
  int is_get;
  int is_post;
  int is_put;
  int is_delete;
  int is_connect;
  int is_options;
  int is_trace;
  int is_patch;
  int is_upgrade;
  int is_websocket_upgrade;
} phr_parse_context;


int phr_parse_request(const char *buf, size_t len, size_t *out_len, int *minor_version, int *method, const char **path, size_t *path_len, const char **query_string, size_t *query_string_len, phr_header **headers, size_t *num_headers);
int phr_parse_headers(const char *buf, size_t len, phr_header **headers, size_t *num_headers);
void phr_free_headers(phr_header *headers, size_t num_headers);

/* end picohttpparser */
"""
)

library_extension = "dll" if platform.system().lower() == "windows" else "so"

library_path_picohttpparser = os.path.join(
    os.path.dirname(__file__),
    "libpicohttpparser_%s_%s.%s"
    % (
        platform.system().lower(),
        "arm64" if "arm" in platform.processor().lower() else "amd64",
        library_extension,
    ),
)


lib2 = ffi2.dlopen(library_path_picohttpparser)
```

dan ini adalah file dari uws.py

```
import cffi
import platform
import os

ffi = cffi.FFI()
ffi.cdef(
    """

struct us_socket_context_options_t {
    const char *key_file_name;
    const char *cert_file_name;
    const char *passphrase;
    const char *dh_params_file_name;
    const char *ca_file_name;
    const char *ssl_ciphers;
    int ssl_prefer_low_memory_usage;
};

struct us_socket_context_t {
    struct us_loop_t *loop;
    unsigned short timestamp;
    struct us_socket_t *head;
    struct us_socket_t *iterator;
    struct us_socket_context_t *prev, *next;
    struct us_socket_t *(*on_open)(struct us_socket_t *, int is_client, char *ip, int ip_length);
    struct us_socket_t *(*on_data)(struct us_socket_t *, char *data, int length);
    struct us_socket_t *(*on_writable)(struct us_socket_t *);
    struct us_socket_t *(*on_close)(struct us_socket_t *, int code, void *reason);
    struct us_socket_t *(*on_socket_timeout)(struct us_socket_t *);
    struct us_socket_t *(*on_end)(struct us_socket_t *);
    struct us_socket_t *(*on_connect_error)(struct us_socket_t *, int code);
    int (*is_low_prio)(struct us_socket_t *);
};
 
struct us_poll_t {
    struct {
        signed int fd : 28;
        unsigned int poll_type : 4;
    } state;
};

struct us_socket_t {
    struct us_poll_t p;
    struct us_socket_context_t *context;
    struct us_socket_t *prev, *next;
    unsigned short timeout : 14;
    unsigned short low_prio_state : 2;
};

struct us_listen_socket_t {
    struct us_socket_t s;
    unsigned int socket_ext_size;
};
void us_listen_socket_close(int ssl, struct us_listen_socket_t *ls);
int us_socket_local_port(int ssl, struct us_listen_socket_t *ls);
struct us_loop_t *uws_get_loop();
struct us_loop_t *uws_get_loop_with_native(void* existing_native_loop);
typedef enum
{
    _COMPRESSOR_MASK = 0x00FF,
    _DECOMPRESSOR_MASK = 0x0F00,
    DISABLED = 0,
    SHARED_COMPRESSOR = 1,
    SHARED_DECOMPRESSOR = 1 << 8,
    DEDICATED_DECOMPRESSOR_32KB = 15 << 8,
    DEDICATED_DECOMPRESSOR_16KB = 14 << 8,
    DEDICATED_DECOMPRESSOR_8KB = 13 << 8,
    DEDICATED_DECOMPRESSOR_4KB = 12 << 8,
    DEDICATED_DECOMPRESSOR_2KB = 11 << 8,
    DEDICATED_DECOMPRESSOR_1KB = 10 << 8,
    DEDICATED_DECOMPRESSOR_512B = 9 << 8,
    DEDICATED_DECOMPRESSOR = 15 << 8,
    DEDICATED_COMPRESSOR_3KB = 9 << 4 | 1,
    DEDICATED_COMPRESSOR_4KB = 9 << 4 | 2,
    DEDICATED_COMPRESSOR_8KB = 10 << 4 | 3,
    DEDICATED_COMPRESSOR_16KB = 11 << 4 | 4,
    DEDICATED_COMPRESSOR_32KB = 12 << 4 | 5,
    DEDICATED_COMPRESSOR_64KB = 13 << 4 | 6,
    DEDICATED_COMPRESSOR_128KB = 14 << 4 | 7,
    DEDICATED_COMPRESSOR_256KB = 15 << 4 | 8,
    DEDICATED_COMPRESSOR = 15 << 4 | 8
} uws_compress_options_t;

typedef enum
{
    CONTINUATION = 0,
    TEXT = 1,
    BINARY = 2,
    CLOSE = 8,
    PING = 9,
    PONG = 10
} uws_opcode_t;

typedef enum
{
    BACKPRESSURE,
    SUCCESS,
    DROPPED
} uws_sendstatus_t;

typedef struct
{
    int port;
    const char *host;
    int options;
} uws_app_listen_config_t;

struct uws_app_s;
struct uws_req_s;
struct uws_res_s;
struct uws_websocket_s;
struct uws_header_iterator_s;
typedef struct uws_app_s uws_app_t;
typedef struct uws_req_s uws_req_t;
typedef struct uws_res_s uws_res_t;
typedef struct uws_socket_context_s uws_socket_context_t;
typedef struct uws_websocket_s uws_websocket_t;

typedef void (*uws_websocket_handler)(uws_websocket_t *ws, void* user_data);
typedef void (*uws_websocket_message_handler)(uws_websocket_t *ws, const char *message, size_t length, uws_opcode_t opcode, void* user_data);
typedef void (*uws_websocket_ping_pong_handler)(uws_websocket_t *ws, const char *message, size_t length, void* user_data);
typedef void (*uws_websocket_close_handler)(uws_websocket_t *ws, int code, const char *message, size_t length, void* user_data);
typedef void (*uws_websocket_upgrade_handler)(uws_res_t *response, uws_req_t *request, uws_socket_context_t *context, void* user_data);
typedef void (*uws_websocket_subscription_handler)(uws_websocket_t *ws, const char *topic_name, size_t topic_name_length, int new_number_of_subscriber, int old_number_of_subscriber, void* user_data);

typedef struct
{
    uws_compress_options_t compression;
    unsigned int maxPayloadLength;
    unsigned short idleTimeout;
    unsigned int maxBackpressure;
    bool closeOnBackpressureLimit;
    bool resetIdleTimeoutOnSend;
    bool sendPingsAutomatically;
    unsigned short maxLifetime;
    uws_websocket_upgrade_handler upgrade;
    uws_websocket_handler open;
    uws_websocket_message_handler message;
    uws_websocket_handler drain;
    uws_websocket_ping_pong_handler ping;
    uws_websocket_ping_pong_handler pong;
    uws_websocket_close_handler close;
    uws_websocket_subscription_handler subscription;
} uws_socket_behavior_t;

typedef struct {
    bool ok;
    bool has_responded;
} uws_try_end_result_t;

typedef void (*uws_listen_handler)(struct us_listen_socket_t *listen_socket, uws_app_listen_config_t config, void *user_data);
typedef void (*uws_listen_domain_handler)(struct us_listen_socket_t *listen_socket, const char* domain, size_t domain_length, int options, void *user_data);
typedef void (*uws_method_handler)(uws_res_t *response, uws_req_t *request, void *user_data);
typedef void (*uws_filter_handler)(uws_res_t *response, int, void *user_data);
typedef void (*uws_missing_server_handler)(const char *hostname, size_t hostname_length, void *user_data);
typedef void (*uws_get_headers_server_handler)(const char *header_name, size_t header_name_size, const char *header_value, size_t header_value_size, void *user_data);


uws_app_t *uws_create_app(int ssl, struct us_socket_context_options_t options);
void uws_app_destroy(int ssl, uws_app_t *app);
void uws_app_get(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_post(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_options(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_delete(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_patch(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_put(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_head(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_connect(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_trace(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);
void uws_app_any(int ssl, uws_app_t *app, const char *pattern, uws_method_handler handler, void *user_data);

void uws_app_run(int ssl, uws_app_t *);

void uws_app_listen(int ssl, uws_app_t *app, int port, uws_listen_handler handler, void *user_data);
void uws_app_listen_with_config(int ssl, uws_app_t *app, uws_app_listen_config_t config, uws_listen_handler handler, void *user_data);
void uws_app_listen_domain(int ssl, uws_app_t *app, const char *domain, size_t domain_length, uws_listen_domain_handler handler, void *user_data);
void uws_app_listen_domain_with_options(int ssl, uws_app_t *app, const char *domain,size_t domain_length, int options, uws_listen_domain_handler handler, void *user_data);
bool uws_constructor_failed(int ssl, uws_app_t *app);
unsigned int uws_num_subscribers(int ssl, uws_app_t *app, const char *topic, size_t topic_length);
bool uws_publish(int ssl, uws_app_t *app, const char *topic, size_t topic_length, const char *message, size_t message_length, uws_opcode_t opcode, bool compress);
void *uws_get_native_handle(int ssl, uws_app_t *app);
void uws_remove_server_name(int ssl, uws_app_t *app, const char *hostname_pattern, size_t hostname_pattern_length);
void uws_add_server_name(int ssl, uws_app_t *app, const char *hostname_pattern, size_t hostname_pattern_length);
void uws_add_server_name_with_options(int ssl, uws_app_t *app, const char *hostname_pattern, size_t hostname_pattern_length, struct us_socket_context_options_t options);
void uws_missing_server_name(int ssl, uws_app_t *app, uws_missing_server_handler handler, void *user_data);
void uws_filter(int ssl, uws_app_t *app, uws_filter_handler handler, void *user_data);

void uws_res_close(int ssl, uws_res_t *res);
void uws_res_end(int ssl, uws_res_t *res, const char *data, size_t length, bool close_connection);
void uws_res_pause(int ssl, uws_res_t *res);
void uws_res_resume(int ssl, uws_res_t *res);
void uws_res_write_continue(int ssl, uws_res_t *res);
void uws_res_write_status(int ssl, uws_res_t *res, const char *status, size_t length);
void uws_res_write_header(int ssl, uws_res_t *res, const char *key, size_t key_length, const char *value, size_t value_length);
void uws_res_override_write_offset(int ssl, uws_res_t *res, uintmax_t offset);

void uws_res_write_header_int(int ssl, uws_res_t *res, const char *key, size_t key_length, uint64_t value);
void uws_res_end_without_body(int ssl, uws_res_t *res, bool close_connection);
bool uws_res_write(int ssl, uws_res_t *res, const char *data, size_t length);
uintmax_t uws_res_get_write_offset(int ssl, uws_res_t *res);
void *uws_res_get_native_handle(int ssl, uws_res_t *res);
bool uws_res_has_responded(int ssl, uws_res_t *res);
void uws_res_on_writable(int ssl, uws_res_t *res, bool (*handler)(uws_res_t *res, uintmax_t, void *opcional_data), void *user_data);
void uws_res_on_aborted(int ssl, uws_res_t *res, void (*handler)(uws_res_t *res, void *opcional_data), void *opcional_data);
void uws_res_on_data(int ssl, uws_res_t *res, void (*handler)(uws_res_t *res, const char *chunk, size_t chunk_length, bool is_end, void *opcional_data), void *opcional_data);
void uws_res_upgrade(int ssl, uws_res_t *res, void *data, const char *sec_web_socket_key, size_t sec_web_socket_key_length, const char *sec_web_socket_protocol, size_t sec_web_socket_protocol_length, const char *sec_web_socket_extensions, size_t sec_web_socket_extensions_length, uws_socket_context_t *ws);
uws_try_end_result_t uws_res_try_end(int ssl, uws_res_t *res, const char *data, size_t length, uintmax_t total_size, bool close_connection);
void uws_res_cork(int ssl, uws_res_t *res,void(*callback)(uws_res_t *res, void* user_data) ,void* user_data);
size_t uws_res_get_remote_address(int ssl, uws_res_t *res, const char **dest);
size_t uws_res_get_remote_address_as_text(int ssl, uws_res_t *res, const char **dest);
size_t uws_res_get_proxied_remote_address(int ssl, uws_res_t *res, const char **dest);
size_t uws_res_get_proxied_remote_address_as_text(int ssl, uws_res_t *res, const char **dest);

bool uws_req_is_ancient(uws_req_t *res);
bool uws_req_get_yield(uws_req_t *res);
void uws_req_set_yield(uws_req_t *res, bool yield);
size_t uws_req_get_url(uws_req_t *res, const char **dest);
size_t uws_req_get_method(uws_req_t *res, const char **dest);
size_t uws_req_get_case_sensitive_method(uws_req_t *res, const char **dest);

size_t uws_req_get_header(uws_req_t *res, const char *lower_case_header, size_t lower_case_header_length, const char **dest);
size_t uws_req_get_query(uws_req_t *res, const char *key, size_t key_length, const char **dest);
size_t uws_req_get_parameter(uws_req_t *res, unsigned short index, const char **dest);
size_t uws_req_get_full_url(uws_req_t *res, const char **dest);
void uws_req_for_each_header(uws_req_t *res, uws_get_headers_server_handler handler, void *user_data);

void uws_ws(int ssl, uws_app_t *app, const char *pattern, uws_socket_behavior_t behavior, void* user_data);
void *uws_ws_get_user_data(int ssl, uws_websocket_t *ws);
void uws_ws_close(int ssl, uws_websocket_t *ws);
uws_sendstatus_t uws_ws_send(int ssl, uws_websocket_t *ws, const char *message, size_t length, uws_opcode_t opcode);
uws_sendstatus_t uws_ws_send_with_options(int ssl, uws_websocket_t *ws, const char *message, size_t length, uws_opcode_t opcode, bool compress, bool fin);
uws_sendstatus_t uws_ws_send_fragment(int ssl, uws_websocket_t *ws, const char *message, size_t length, bool compress);
uws_sendstatus_t uws_ws_send_first_fragment(int ssl, uws_websocket_t *ws, const char *message, size_t length, bool compress);
uws_sendstatus_t uws_ws_send_first_fragment_with_opcode(int ssl, uws_websocket_t *ws, const char *message, size_t length, uws_opcode_t opcode, bool compress);
uws_sendstatus_t uws_ws_send_last_fragment(int ssl, uws_websocket_t *ws, const char *message, size_t length, bool compress);
void uws_ws_end(int ssl, uws_websocket_t *ws, int code, const char *message, size_t length);
void uws_ws_cork(int ssl, uws_websocket_t *ws, void (*handler)(void *user_data), void *user_data);

bool uws_ws_subscribe(int ssl, uws_websocket_t *ws, const char *topic, size_t length);
bool uws_ws_unsubscribe(int ssl, uws_websocket_t *ws, const char *topic, size_t length);
bool uws_ws_is_subscribed(int ssl, uws_websocket_t *ws, const char *topic, size_t length);
void uws_ws_iterate_topics(int ssl, uws_websocket_t *ws, void (*callback)(const char *topic, size_t length, void *user_data), void *user_data);
bool uws_ws_publish(int ssl, uws_websocket_t *ws, const char *topic, size_t topic_length, const char *message, size_t message_length);
bool uws_ws_publish_with_options(int ssl, uws_websocket_t *ws, const char *topic, size_t topic_length, const char *message, size_t message_length, uws_opcode_t opcode, bool compress);
int uws_ws_get_buffered_amount(int ssl, uws_websocket_t *ws);
size_t uws_ws_get_remote_address(int ssl, uws_websocket_t *ws, const char **dest);
size_t uws_ws_get_remote_address_as_text(int ssl, uws_websocket_t *ws, const char **dest);



typedef void (*socketify_prepare_handler)(void* user_data);
typedef void (*socketify_timer_handler)(void* user_data);
typedef void (*socketify_async_handler)(void* user_data);

typedef enum {
  SOCKETIFY_RUN_DEFAULT = 0,
  SOCKETIFY_RUN_ONCE,
  SOCKETIFY_RUN_NOWAIT
} socketify_run_mode;

typedef struct {
    void* uv_prepare_ptr;
    socketify_prepare_handler on_prepare_handler;
    void* on_prepare_data;
    void* uv_loop;
} socketify_loop;

typedef struct{
    void* uv_timer_ptr;
    socketify_timer_handler handler;
    void* user_data;
} socketify_timer;

typedef struct{
    void* uv_async_ptr;
    socketify_async_handler handler;
    void* user_data;
} socketify_async;

socketify_loop * socketify_create_loop();
bool socketify_constructor_failed(socketify_loop* loop);
bool socketify_on_prepare(socketify_loop* loop, socketify_prepare_handler handler, void* user_data);
bool socketify_prepare_unbind(socketify_loop* loop);
void socketify_destroy_loop(socketify_loop* loop);
void* socketify_get_native_loop(socketify_loop* loop);

int socketify_loop_run(socketify_loop* loop, socketify_run_mode mode);
void socketify_loop_stop(socketify_loop* loop);

socketify_timer* socketify_create_timer(socketify_loop* loop, uint64_t timeout, uint64_t repeat, socketify_timer_handler handler, void* user_data);
void socketify_timer_destroy(socketify_timer* timer);
bool socketify_async_call(socketify_loop* loop, socketify_async_handler handler, void* user_data);
void socketify_timer_set_repeat(socketify_timer* timer, uint64_t repeat);


socketify_timer* socketify_create_check(socketify_loop* loop, socketify_timer_handler handler, void* user_data);
void socketify_check_destroy(socketify_timer* timer);

typedef struct {

  const char* name;
  const char* value;
  
  size_t name_size;
  size_t value_size;
  
  void* next;
} socketify_header;


typedef struct {

  const char* full_url;
  const char* url;
  const char* query_string;
  const char* method;
  const char* remote_address;

  size_t full_url_size;
  size_t url_size;
  size_t query_string_size;
  size_t method_size;
  size_t remote_address_size;

  socketify_header* header_list;
  bool has_content;
} socketify_asgi_data;

typedef struct {

  const char* full_url;
  const char* url;
  const char* query_string;
  const char* method;
  const char* remote_address;

  size_t full_url_size;
  size_t url_size;
  size_t query_string_size;
  size_t method_size;
  size_t remote_address_size;

  const char* protocol;
  const char* key;
  const char* extensions;
  size_t protocol_size;
  size_t key_size;
  size_t extensions_size;

  socketify_header* header_list;
} socketify_asgi_ws_data;

typedef void (*socketify_asgi_method_handler)(int ssl, uws_res_t *response, socketify_asgi_data request, void *user_data);
typedef struct {
  int ssl;
  uws_app_t* app;
  socketify_asgi_method_handler handler;
  void * user_data;
} socksocketify_asgi_app_info;
typedef void (*socketify_asgi_ws_method_handler)(int ssl, uws_res_t *response, socketify_asgi_ws_data request, uws_socket_context_t* socket, void *user_data);
typedef struct {
  int ssl;
  uws_app_t* app;
  socketify_asgi_ws_method_handler handler;
  uws_socket_behavior_t behavior;
  void * user_data;
} socketify_asgi_ws_app_info;

socketify_asgi_data socketify_asgi_request(int ssl, uws_req_t *req, uws_res_t *res);
void socketify_destroy_headers(socketify_header* headers);
bool socketify_res_write_int_status_with_headers(int ssl, uws_res_t* res, int code, socketify_header* headers);
void socketify_res_write_headers(int ssl, uws_res_t* res, socketify_header* headers);
socketify_asgi_ws_data socketify_asgi_ws_request(int ssl, uws_req_t *req, uws_res_t *res);
bool socketify_res_write_int_status(int ssl, uws_res_t* res, int code);

void socketify_res_cork_write(int ssl, uws_res_t *response, const char* data, size_t length);
void socketify_res_cork_end(int ssl, uws_res_t *response, const char* data, size_t length, bool close_connection);
void socketify_ws_cork_send(int ssl, uws_websocket_t *ws, const char* data, size_t length, uws_opcode_t opcode);


void socketify_ws_cork_send_with_options(int ssl, uws_websocket_t *ws, const char* data, size_t length, uws_opcode_t opcode, bool compress, bool close_connection);

void socketify_res_send_int_code(int ssl, uws_res_t *res, const char* content_data, size_t content_data_size, int code, const char *content_type, size_t content_type_size, bool close_connection);
void socketify_res_send(int ssl, uws_res_t *res, const char *content_data, size_t content_data_size, const char *status_code, size_t status_code_size, const char *content_type, size_t content_type_size, bool close_connection);

void socketify_res_cork_send_int_code(int ssl, uws_res_t *res, const char* content_data, size_t content_data_size, int code, const char *content_type, size_t content_type_size, bool close_connection);
void socketify_res_cork_send(int ssl, uws_res_t *res, const char *content_data, size_t content_data_size, const char *status_code, size_t status_code_size, const char *content_type, size_t content_type_size, bool close_connection);

"""
)

library_extension = "dll" if platform.system().lower() == "windows" else "so"

library_path_socketify = os.path.join(
    os.path.dirname(__file__),
    "libsocketify_%s_%s.%s"
    % (
        platform.system().lower(),
        "arm64" if "arm" in platform.processor().lower() else "amd64",
        library_extension,
    ),
)
lib = ffi.dlopen(library_path_socketify)
```
